#pragma kernel FlowSimulation
#pragma kernel Init
#include <UnityCG.cginc>

RWTexture2D<float4> dataMap1; // r = heightMap, g = suspended sediment, b = water level
RWTexture2D<float4> fluxMap; // pipe model flux field | r = left, g = top, b = right, a = bottom
RWTexture2D<float4> velocityField; // velocity field

float2 waterSource = float2(300, 400);
float simulationTimeStep;
float waterSourceStrength;
float pipeCrossSection;
float lengthPipe = 1;
float gravity = 9.81;

float deltaHeight(uint2 id, uint2 offset)
{
    return dataMap1[id].r + dataMap1[id].b - dataMap1[id + offset].r - dataMap1[id + offset].b;
}

float WaterInc (uint2 id)
{
    // TODO: add modifiable water sources
    // TODO: add rain water distribution
    if (id.x == waterSource.x && id.y == waterSource.y)
    {
        return  simulationTimeStep * waterSourceStrength;
    }

    return 0;
}

[numthreads(8,8,1)]
void Init (uint3 id : SV_DispatchThreadID)
{
    dataMap1[id.xy].gb = 0;
}

[numthreads(8,8,1)]
void FlowSimulation (uint3 id : SV_DispatchThreadID)
{
    // TODO: consider and fix border cells with neighbours outside the grid
    
    float waterDelta1 = WaterInc(id.xy);

    // Flux field
    uint2 offset = uint2(-1, 0);
    float fluxL = max(0, fluxMap[id.xy + offset] + simulationTimeStep * pipeCrossSection * (gravity * deltaHeight(id, offset) / lengthPipe));
    offset = uint2(1, 0);
    float fluxR = max(0, fluxMap[id.xy + offset] + simulationTimeStep * pipeCrossSection * (gravity * deltaHeight(id, offset) / lengthPipe));
    offset = uint2(0, -1);
    float fluxT = max(0, fluxMap[id.xy + offset] + simulationTimeStep * pipeCrossSection * (gravity * deltaHeight(id, offset) / lengthPipe));
    offset = uint2(0, 1);
    float fluxB = max(0, fluxMap[id.xy + offset] + simulationTimeStep * pipeCrossSection * (gravity * deltaHeight(id, offset) / lengthPipe));

    float k = min(1, (dataMap1[id.xy].b * 1 * 1) / ((fluxL + fluxR + fluxB + fluxT) * simulationTimeStep));

    fluxMap[id.xy].r = k * fluxL;
    fluxMap[id.xy].g = k * fluxT;
    fluxMap[id.xy].b = k * fluxR;
    fluxMap[id.xy].a = k * fluxB;

    // Water height
    float deltaVolume = simulationTimeStep *
        (fluxMap[id.xy + uint2(1, 0)].r + fluxMap[id.xy + uint2(0, -1)].g + fluxMap[id.xy + uint2(-1, 0)].b + fluxMap[id.xy + uint2(0, 1)].a)
        - (fluxMap[id.xy].r + fluxMap[id.xy].g + fluxMap[id.xy].b + fluxMap[id.xy].a);

    float waterDelta2 = waterDelta1 + deltaVolume / lengthPipe;

    // Velocity field
    float averageWaterDelta = (waterDelta1 + waterDelta2) / 2;
    float deltaFlowX = (fluxMap[id.xy + uint2(-1, 0)].b - fluxMap[id.xy].r + fluxMap[id.xy].b - fluxMap[id.xy + uint2(1, 0)].r) / 2;
    float deltaFlowY = (fluxMap[id.xy + uint2(0, -1)].g - fluxMap[id.xy].a + fluxMap[id.xy].g - fluxMap[id.xy + uint2(0, 1)].a) / 2;
    
    velocityField[id.xy].x = deltaFlowX / (averageWaterDelta * lengthPipe);
    velocityField[id.xy].y = deltaFlowY / (averageWaterDelta * lengthPipe);

    // Erosion and Deposition
}